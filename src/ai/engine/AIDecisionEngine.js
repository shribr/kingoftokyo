/**
 * Enhanced AI Decision Engine (modular relocation)
 * Source migrated from previous monolithic file new/js/ai-decisions.js
 * to a structured module under src/ai/engine for cleaner integration.
 * NOTE: Identifiers preserved; no runtime "legacy" naming retained.
 */
(function(global){
  if (typeof window === 'undefined') { global.window = {}; }
  if (typeof window.performance === 'undefined') { window.performance = { now: () => Date.now() }; }
  if (typeof global.performance === 'undefined') { global.performance = window.performance; }
})(typeof globalThis !== 'undefined' ? globalThis : (typeof global !== 'undefined'? global : this));

// Deterministic utilities (only active when test flag set)
import { isDeterministicMode, deriveDecisionSeed, createSeededRNG } from '../../core/rng.js';

// Module-level counters (reset per turnCycleId) for stable decision indexing
let __decisionCounter = 0;
let __lastTurnCycleId = null;

const PROFILING_ENABLED = typeof window !== 'undefined' && !!window.AI_PROFILING;
const AIDecisionProfiler = {
  enabled: PROFILING_ENABLED,
  samples: [],
  record(label, ms){ if(!this.enabled) return; this.samples.push({ label, ms, t: Date.now() }); if (this.samples.length > 400) this.samples.shift(); },
  stats(){ if(!this.samples.length) return null; const arr=this.samples.map(s=>s.ms); const sum=arr.reduce((a,b)=>a+b,0); return { count:arr.length, avg:+(sum/arr.length).toFixed(2), min:+Math.min(...arr).toFixed(2), max:+Math.max(...arr).toFixed(2) }; },
  maybeLog(){ if(!this.enabled) return; if(this.samples.length && this.samples.length % 40 === 0){ const s=this.stats(); if (s) console.log('ðŸ§ª Enhanced AI Profiling', s); } }
};
if (typeof window !== 'undefined') window.NewAIDecisionProfiler = AIDecisionProfiler;

const CFG = { goalAlignmentMultiplier:1.55, pairScoreBase:60, singleThree:15, singleTwo:10, singleOne:6, formedSetBase:200, fourKindEVFocus:0.55, earlyStopMinKept:4, earlyStopImprovementThreshold:0.55, healingCriticalHP:4, keepThresholdBase:6 };
const CARD_TAGS = { extraDie:['Extra Head','extra_head'], extraReroll:['Giant Brain','giant_brain'], attackBoost:['Acid Attack','acid_attack','Fire Breathing','fire_breathing','Spiked Tail','spiked_tail'], vpBoost:['Friend of Children','friend_of_children','Dedicated News Team','dedicated_news_team','Even Bigger','even_bigger'], energyEngine:['Alien Metabolism','alien_metabolism','Corner Store','corner_store','Energy Hoarder','energy_hoarder'], healEngine:['Regeneration','regeneration','Rapid Healing','rapid_healing','Healing Ray','healing_ray'] };
function choose(n,k){ if (k<0||k>n) return 0; if (k===0||k===n) return 1; k=Math.min(k,n-k); let c=1; for(let i=0;i<k;i++) c=c*(n-(k-1-i))/(i+1); return c; }

class AIDecisionEngine {
  constructor(){ if (typeof window !== 'undefined') { window.NewAIOverrideStats = window.NewAIOverrideStats || { decisions:0, invariants:0, pairProtect:0 }; } }
  makeRollDecision(currentDice, rollsRemaining, player, gameState){ try { return this._core(currentDice, rollsRemaining, player, gameState); } catch(err){ console.error('[Enhanced AI] Fallback due to error:', err); return { action:'reroll', keepDice:[], reason:'AI error fallback', confidence:0.30 }; } }
  _core(diceRaw, rollsRemaining, player, gameState){
    const start=performance.now();
    const dice=diceRaw.map(f=>this._canon(f));
    const state=this._extractState(dice, rollsRemaining, player, gameState);
    state.personality={ aggression:player.monster?.personality?.aggression ?? 3, risk:player.monster?.personality?.risk ?? 3, strategy:player.monster?.personality?.strategy ?? 3 };

    // Deterministic context (seed per decision)
    const deterministicActive = isDeterministicMode();
    const turnCycleId = gameState?.meta?.turnCycleId ?? gameState?.turnCycleId ?? 0;
    if (__lastTurnCycleId !== turnCycleId){ __lastTurnCycleId = turnCycleId; __decisionCounter = 0; }
    const decisionIndex = __decisionCounter++;
    let decisionSeed=null, decisionRng=null, trialsOverride=null;
    if (deterministicActive){
      decisionSeed = deriveDecisionSeed('KOT_AI', turnCycleId, decisionIndex, player?.id||0);
      decisionRng = createSeededRNG(decisionSeed);
      trialsOverride = 64; // fixed trial count for reproducibility
    }
    const deterministicCtx = { active:deterministicActive, seed:decisionSeed, rng:decisionRng, decisionIndex, turnCycleId, trialsOverride };

    const goal=this._selectOrMaintainGoal(state, player);
    const scored=this._scoreDice(state, goal, player);
    const ev=this._computeSetEV(state, goal);
    let decision=this._assembleDecision(state, goal, scored, ev, rollsRemaining, player, deterministicCtx);
    decision=this._enforceInvariants(decision, state, rollsRemaining);
    if (deterministicActive){
      const durationMs = +(performance.now()-start).toFixed(2);
      decision.deterministic = decision.deterministic || { seed:decisionSeed, trials:trialsOverride, turnCycleId, decisionIndex, durationMs };
    }
    this._lastPerFaceProbabilities=scored.map(s=>({ index:s.index, face:s.face, keepProbability:+(s.normScore||0).toFixed(3) }));
    if (typeof window !== 'undefined') window.NewAIOverrideStats.decisions++;
    AIDecisionProfiler.record('totalDecision', performance.now()-start);
    AIDecisionProfiler.maybeLog();
    return decision;
  }
  _extractState(dice, rollsRemaining, player, gameState){ const counts={ one:0,two:0,three:0,attack:0,energy:0,heart:0 }; dice.forEach(f=>{ if (counts.hasOwnProperty(f)) counts[f]++; }); const numbers=['one','two','three'].map(face=>({ face, count:counts[face], faceValue:face==='one'?1:face==='two'?2:3, pair:counts[face]===2, formed:counts[face]>=3 })); const maxVP=Math.max(...gameState.players.map(p=>p.victoryPoints)); const alive=gameState.players.filter(p=>!p.isEliminated).length; const phase=maxVP>=15||alive<=2?'end':(maxVP>=10?'mid':'early'); const tokyoOccupant=gameState.players.find(p=>p.isInTokyo && !p.isEliminated)||null; const criticalThreat=gameState.players.some(p=>p.id!==player.id && !p.isEliminated && p.victoryPoints>=18); const cardSummary=this._summarizeCards(player.powerCards||[]); const effectiveRollsRemaining=rollsRemaining + (cardSummary.extraReroll>0?1:0); let shopCards=[]; try { if (gameState && Array.isArray(gameState.availablePowerCards)) { shopCards=gameState.availablePowerCards.slice(0,3).map(c=>({ name:c.name, cost:c.cost, id:c.id, effects:c.effects })); } } catch(_){} return { dice, counts, numbers, phase, tokyoOccupant, criticalThreat, cardSummary, player, rollsRemaining:effectiveRollsRemaining, origRolls:rollsRemaining, shopCards }; }
  _summarizeCards(cards){ const flags={ extraDie:0,extraReroll:0,attackBoost:0,vpBoost:0,energyEngine:0,healEngine:0,bonusVP:0,bonusEnergyFlat:0,healPoints:0 }; cards.forEach(c=>{ const name=(c.name||c.id||'').toLowerCase(); for(const k of Object.keys(CARD_TAGS)){ if (CARD_TAGS[k].some(tag=> tag.toLowerCase()===name)) flags[k]++; } if (Array.isArray(c.effects)){ c.effects.forEach(e=>{ const type=(e.type||'').toLowerCase(); const val=Number(e.value||e.amount||1)||1; switch(type){ case 'extradie': flags.extraDie+=val; break; case 'extrareroll': flags.extraReroll+=val; break; case 'attackbonus': flags.attackBoost+=val; break; case 'bonusenergy': flags.energyEngine+=val; flags.bonusEnergyFlat+=val; break; case 'healpoints': flags.healEngine+=Math.ceil(val/2); flags.healPoints+=val; break; case 'victorypoints': flags.vpBoost+=Math.ceil(val/2); flags.bonusVP+=val; break; default: break; } }); } }); return flags; }
  _selectOrMaintainGoal(state, player){ if (player._aiTurnGoal){ const face=player._aiTurnGoal.face; if (state.counts[face] > 0){ if (face==='one'){ const twoCount=state.counts.two; const threeCount=state.counts.three; if (state.counts.one===3 && state.rollsRemaining>=2 && (threeCount>=2 || twoCount>=2)){ const targetFace=threeCount>=2? 'three':'two'; player._aiTurnGoal={ type:'numberSet', face:targetFace, at:Date.now(), fosteredFrom:'one' }; return player._aiTurnGoal; } } return player._aiTurnGoal; } }
    const candidates=state.numbers.filter(n=>n.count>=2); if (candidates.length){ candidates.sort((a,b)=> b.count - a.count || b.faceValue - a.faceValue); const chosen=candidates[0]; player._aiTurnGoal={ type:'numberSet', face:chosen.face, at:Date.now(), countAtSel:chosen.count }; return player._aiTurnGoal; }
    if (!player._aiTurnGoal && state.rollsRemaining>=2 && state.counts.three===1){ player._aiTurnGoal={ type:'numberSet', face:'three', at:Date.now(), countAtSel:1, provisional:true }; return player._aiTurnGoal; }
    return null; }
  _scoreDice(state, goal, player){ const { counts, phase, cardSummary, personality } = state; const needHealing = player.health <= CFG.healingCriticalHP; const attackPressure = state.tokyoOccupant && state.tokyoOccupant.id !== player.id ? 1:0; const tokyoEmpty  = !state.tokyoOccupant; const tokyoSelf   = !!player.isInTokyo; const enemyTokyo  = state.tokyoOccupant && state.tokyoOccupant.id !== player.id ? state.tokyoOccupant : null; const arr=[]; let energyUrgencyBonus=0; let portfolioDesiredFeature=null; if (state.shopCards && state.shopCards.length) { try { if (typeof this.optimizePowerCardPortfolio === 'function') { const plan=this.optimizePowerCardPortfolio(state.shopCards.map(c=>({...c})), player); if (plan && plan.cards && plan.cards.length) { const featurePriority=['extraDie','extraReroll','attack','energy','heal','vp']; const feats=this._extractCardFeatures(plan.cards[0]); portfolioDesiredFeature = featurePriority.find(f=> feats.has(f)) || null; } } } catch(e){} const impactful = state.shopCards.map(c=>{ const feats=this._extractCardFeatures(c); let impactScore=0; if (feats.has('extraDie')) impactScore+=30; if (feats.has('extraReroll')) impactScore+=24; if (feats.has('attack')) impactScore+=14; if (feats.has('heal') && player.health <= CFG.healingCriticalHP) impactScore+=12; if (feats.has('vp') && phase!=='early') impactScore+=10; const shortfall=Math.max(0,(c.cost||0)-player.energy); return { impactScore, shortfall }; }).filter(m=>m.impactScore>0).sort((a,b)=> (a.shortfall - b.shortfall) || (b.impactScore - a.impactScore)); if (impactful.length){ const top=impactful[0]; if (top.shortfall>0){ energyUrgencyBonus = Math.max(4,(top.impactScore/10)) * (top.shortfall<=2 ? 1.4:1); } } }
    state.dice.forEach((face,index)=>{ let score=0, locked=false; if (face==='one'||face==='two'||face==='three'){ const count=counts[face]; if (count>=3){ score = CFG.formedSetBase + count; locked=true; } else if (count===2){ score = CFG.pairScoreBase + (face==='three'?18: face==='two'?10:5); } else { score = face==='three'? CFG.singleThree: face==='two'? CFG.singleTwo: CFG.singleOne; if (face==='one' && (counts.three>=2 || counts.two>=2)) score*=0.3; } if (goal && goal.face===face && !locked) score*=CFG.goalAlignmentMultiplier; if (cardSummary.vpBoost) score *= (1 + 0.15*cardSummary.vpBoost); } else if (face==='attack') { const aggressionAdj = 1 + ((personality.aggression - 3)*0.15); const threatBonus   = state.criticalThreat?12:0; let baseAtk = 18 + attackPressure*8 + threatBonus; if (tokyoEmpty && !tokyoSelf && player.health >=6) baseAtk += 6 + (personality.aggression-3)*2; if (enemyTokyo){ if (enemyTokyo.health<=5) baseAtk+=5; if (enemyTokyo.victoryPoints>=10) baseAtk+=5; } if (tokyoSelf && player.health <=5) baseAtk -= 6; score = baseAtk * aggressionAdj; if (cardSummary.attackBoost) score += 6*cardSummary.attackBoost; if (player.isInTokyo) score -=4; if (goal && counts[goal.face]===2) score*=0.75; } else if (face==='energy') { const baseEnergy = phase==='early'?16: phase==='mid'?12:8; const stratAdj = 1 + ((personality.strategy - 3) * 0.12); const riskAdj  = 1 - ((personality.risk - 3) * 0.07); score = (baseEnergy * stratAdj * riskAdj) + energyUrgencyBonus; if (portfolioDesiredFeature && ['extraDie','extraReroll'].includes(portfolioDesiredFeature)) score*=1.15; if (cardSummary.energyEngine) score += 5*cardSummary.energyEngine; if (player.energy<=2) score+=6; if (goal && counts[goal.face]===2) score*=0.85; } else if (face==='heart') { const riskHealScale = 1 - ((personality.risk - 3) * 0.12); let baseHeal = player.health <= CFG.healingCriticalHP? (25 + (CFG.healingCriticalHP - player.health)*4): (player.health===player.maxHealth?0:10); if (!tokyoSelf && player.health < player.maxHealth && player.health <=6) baseHeal += 6; score = baseHeal * riskHealScale; if (cardSummary.healEngine) score += 4*cardSummary.healEngine; if (player.isInTokyo) score=0; } arr.push({ index, face, score, locked }); }); const max=Math.max(1,...arr.map(s=>s.score)); arr.forEach(s=> s.normScore = s.score / max); return arr; }
  _projectTwoRollEV(state, keepIndices, deterministicCtx){
    try {
      if (state.rollsRemaining <=1) return null;
      let baseTrials=60;
      if (deterministicCtx?.active && deterministicCtx.trialsOverride){
        baseTrials = deterministicCtx.trialsOverride;
      } else if (AIDecisionProfiler.enabled){
        const s=AIDecisionProfiler.stats();
        if (s){ if (s.avg<12) baseTrials=110; else if (s.avg<18) baseTrials=80; else if (s.avg>35) baseTrials=40; else if (s.avg>50) baseTrials=25; }
      }
      const TRIALS=baseTrials;
      const faces=['one','two','three','attack','energy','heart'];
      const rng = deterministicCtx?.rng || Math.random;
      let aggregate={ tripleGain:0, attack:0, energy:0, heal:0 };
      for(let t=0;t<TRIALS;t++){
        let dice=state.dice.slice();
        for(let i=0;i<dice.length;i++) if (!keepIndices.has(i)) dice[i]=faces[Math.floor(rng()*faces.length)];
        const counts={ one:0,two:0,three:0,attack:0,energy:0,heart:0 };
        dice.forEach(f=>counts[f]++);
        const numSorted=['one','two','three'].map(f=>({f,c:counts[f]})).sort((a,b)=> b.c - a.c || (b.f==='three'?1:-1));
        const target=numSorted[0];
        for(let i=0;i<dice.length;i++){
          if (dice[i]!==target.f && !['attack','energy','heart'].includes(dice[i])){
            if (rng()<0.8) dice[i]=faces[Math.floor(rng()*faces.length)];
          }
        }
        const finalCounts={ one:0,two:0,three:0,attack:0,energy:0,heart:0 };
        dice.forEach(f=>finalCounts[f]++);
        if (finalCounts[target.f] >=3) aggregate.tripleGain+=1;
        aggregate.attack+=finalCounts.attack;
        aggregate.energy+=finalCounts.energy;
        aggregate.heal+=finalCounts.heart;
      }
      return { tripleChance:+(aggregate.tripleGain/TRIALS).toFixed(3), avgAttack:+(aggregate.attack/TRIALS).toFixed(2), avgEnergy:+(aggregate.energy/TRIALS).toFixed(2), avgHeal:+(aggregate.heal/TRIALS).toFixed(2), trials:TRIALS };
    } catch(e){ return null; }
  }
  _computeSetEV(state, goal){ const extraDie=state.cardSummary?.extraDie||0; const effectiveDiceCount=state.dice.length + extraDie; const committed=state.numbers.filter(n=>n.formed).reduce((a,n)=>a+n.count,0); const free=Math.max(0, effectiveDiceCount - committed); const R=state.rollsRemaining; const items=[]; state.numbers.forEach(n=>{ if (R<=0) return; if (n.count===2){ const pTriple = 1 - Math.pow(5/6, free * R); items.push({ face:n.face, type:'completeTriple', ev: pTriple * n.faceValue }); } else if (n.count===3){ const p4 = 1 - Math.pow(5/6, free * R * CFG.fourKindEVFocus); items.push({ face:n.face, type:'fourKind', ev: p4 * 0.9 }); if (free>=2 || (free>=1 && (state.cardSummary.extraReroll>0 || extraDie>0))){ const expectedMatches = Math.min(2,(free * R)/6); const ev5 = expectedMatches>1? (expectedMatches-1)*0.75 : 0; if (ev5>0) items.push({ face:n.face, type:'fiveKindChase', ev:ev5 }); } } else if (n.count===4){ if (free>0){ const p5 = 1 - Math.pow(5/6, free * R * 0.65); items.push({ face:n.face, type:'fiveKind', ev:p5*0.8 }); } } }); let total=items.reduce((s,i)=>s+i.ev,0); if (R>0 && free>0){ const expPerFace = (free * R)/6; const player=state.player; const phase=state.phase; const threatFactor=state.criticalThreat?1.4:1; const lowHP=player.health <= CFG.healingCriticalHP; const attackEV=expPerFace * 0.9 * threatFactor; const healEV=lowHP? expPerFace*1.2: expPerFace*0.2; const energyEV = phase==='early'? expPerFace*0.9: phase==='mid'? expPerFace*0.6: expPerFace*0.3; const additive=attackEV + healEV + energyEV; if (additive>0){ items.push({ face:'*', type:'additiveFuture', ev:additive }); total+=additive; } } return { items, total }; }
  _simulateBranches(state){ try { const counts=state.counts; const groups=['one','two','three'].map(f=>({face:f,count:counts[f]})).filter(g=>g.count>0).sort((a,b)=> b.count - a.count || (b.face==='three'?1:-1)); const specials=state.dice.map((f,i)=>({f,i})).filter(d=> !['one','two','three'].includes(d.f)); const branches=[]; const primary=groups[0]?.face; const baseKeep=[]; state.dice.forEach((f,i)=>{ if (groups.some(g=>g.face===f && g.count>=3)) baseKeep.push(i); }); if (primary){ state.dice.forEach((f,i)=>{ if (f===primary && !baseKeep.includes(i)) baseKeep.push(i); }); } branches.push({ tag:'baseline', kept:baseKeep.slice() }); if (specials.length){ const sortedSpec=specials.slice().sort((a,b)=>{ const pr={ heart:1, energy:2, attack:3 }; return (pr[a.f]||5)-(pr[b.f]||5); }); const alt=baseKeep.filter(i=> !sortedSpec.some(s=>s.i===i)); branches.push({ tag:'free_one_special', kept:alt }); } if (groups.length>1 && groups[1].count===2){ const secondary=groups[1].face; const secondKeep=[]; state.dice.forEach((f,i)=>{ if (f===secondary) secondKeep.push(i); }); groups.forEach(g=>{ if (g.count>=3){ state.dice.forEach((f,i)=>{ if(f===g.face && !secondKeep.includes(i)) secondKeep.push(i); }); } }); branches.push({ tag:'secondary_pair_focus', kept:secondKeep }); } const numbersOnly=[]; state.dice.forEach((f,i)=>{ if(['one','two','three'].includes(f)) numbersOnly.push(i); else if (f==='heart' && state.player.health<=CFG.healingCriticalHP) numbersOnly.push(i); }); branches.push({ tag:'numbers_only', kept:numbersOnly }); const evaluated = branches.map(br=>{ const keptFaces=br.kept.map(i=>state.dice[i]); const freq={ one:0,two:0,three:0,attack:0,energy:0,heart:0 }; keptFaces.forEach(f=>{ if(freq.hasOwnProperty(f)) freq[f]++; }); let formedValue=0; ['one','two','three'].forEach(n=>{ if (freq[n]>=3) formedValue += CFG.formedSetBase + (n==='three'?30: n==='two'?15:10); else if (freq[n]===2) formedValue += CFG.pairScoreBase + (n==='three'?18: n==='two'?10:5); }); let specialUtility=0; specialUtility += freq.attack * 20; specialUtility += freq.energy * (state.phase==='early'?18: state.phase==='mid'?12:8); if (!state.player.isInTokyo) specialUtility += freq.heart * (state.player.health <= CFG.healingCriticalHP ? 22: 6); const improvementEV = (state.rollsRemaining>0)? (state.rollsRemaining * (state.dice.length - br.kept.length) * 0.9):0; const score = formedValue + specialUtility + improvementEV; return { tag:br.tag, kept:br.kept.slice().sort((a,b)=>a-b), formedValue, specialUtility, improvementEV, score }; }).sort((a,b)=> b.score - a.score); return { evaluated, best:evaluated[0] }; } catch(e){ return null; } }
  _assembleDecision(state, goal, scored, ev, rollsRemaining, player, deterministicCtx){ const t0=performance.now(); const keep=new Set(); const releasedIndices=[]; const branchSim=this._simulateBranches(state); let primaryFace=goal?.face || null; if (!primaryFace){ const sorted=state.numbers.slice().sort((a,b)=> b.count - a.count || b.face.localeCompare(a.face)); primaryFace = sorted.length? sorted[0].face:null; } const formedFaces=new Set(state.numbers.filter(n=>n.formed).map(n=>n.face)); const hasFormed=formedFaces.size>0; state.numbers.forEach(n=>{ if (n.formed){ state.dice.forEach((f,i)=>{ if(f===n.face) keep.add(i); }); } else if (n.pair){ if (n.face===primaryFace){ state.dice.forEach((f,i)=>{ if(f===n.face) keep.add(i); }); } else if (!hasFormed && rollsRemaining>0){ state.dice.forEach((f,i)=>{ if(f===n.face) keep.add(i); }); } else if (hasFormed && rollsRemaining===0){ state.dice.forEach((f,i)=>{ if(f===n.face) keep.add(i); }); } } }); if (rollsRemaining>=2){ const unformedPairs=state.numbers.filter(n=> n.pair && !n.formed); if (unformedPairs.length>0 && keep.size===state.dice.length){ const specials=[]; state.dice.forEach((f,i)=>{ if(!['one','two','three'].includes(f)) specials.push({face:f,index:i}); }); if (specials.length){ const pr={ heart:1, energy:2, attack:3 }; specials.sort((a,b)=> (pr[a.face]||5)-(pr[b.face]||5)); keep.delete(specials[0].index); releasedIndices.push(specials[0].index); } } }
    const pairCount=state.numbers.filter(n=>n.pair).length; scored.filter(s=> !keep.has(s.index) && !['one','two','three'].includes(s.face)).forEach(s=>{ const threshold=CFG.keepThresholdBase * (pairCount>=2?1.1:1); if (s.score >= threshold) keep.add(s.index); }); if (goal){ const goalIdxs=[]; state.dice.forEach((f,i)=>{ if(f===goal.face) goalIdxs.push(i); }); if (goalIdxs.length>=2) goalIdxs.forEach(i=>keep.add(i)); }
    if (goal && goal.type==='numberSet' && ['one','two','three'].includes(goal.face)){ const counts=state.counts; const goalCount=counts[goal.face]||0; if (goalCount < 3 && rollsRemaining>0){ let freeDice=state.dice.length - Array.from(keep).length; if (freeDice<2){ const keptSpecials=[]; state.dice.forEach((f,i)=>{ if(keep.has(i) && !['one','two','three'].includes(f)) keptSpecials.push({face:f,index:i}); }); const pr={ heart:1, energy:2, attack:3 }; keptSpecials.sort((a,b)=> (pr[a.face]||5)-(pr[b.face]||5)); for (const sp of keptSpecials){ if (freeDice>=2) break; keep.delete(sp.index); releasedIndices.push(sp.index); freeDice++; } if (freeDice<2){ const secondaryPairs=['one','two','three'].filter(f=> f!==goal.face && counts[f]===2).sort((a,b)=>({one:1,two:2,three:3})[a]-({one:1,two:2,three:3})[b]); for(const sf of secondaryPairs){ if (freeDice>=2) break; const idxs=[]; state.dice.forEach((f,i)=>{ if(f===sf) idxs.push(i); }); if (idxs.length===2){ const rel=idxs[1]; if (keep.delete(rel)){ releasedIndices.push(rel); freeDice++; } } } } if (goalCount<3){ let freeNow=state.dice.length - Array.from(keep).length; if (freeNow===0){ const candidates=[]; state.dice.forEach((f,i)=>{ if (keep.has(i) && f!==goal.face){ let priority=10; if(['one','two','three'].includes(f)){ priority={one:1,two:2,three:3}[f]||9; } else { priority={ heart:0, energy:1, attack:2 }[f] ?? 8; } candidates.push({index:i,face:f,priority}); } }); candidates.sort((a,b)=> a.priority - b.priority); if (candidates.length){ const rel=candidates[0]; if (keep.delete(rel.index)){ releasedIndices.push(rel.index); freeNow++; } } } } } } }
    let kept=Array.from(keep).sort((a,b)=>a-b); let freeDice=state.dice.length - kept.length; const unresolvedPairFaces=state.numbers.filter(n=> n.pair && !n.formed).map(n=>n.face); if (rollsRemaining>0 && unresolvedPairFaces.length>0 && freeDice===0){ const secondaryPairFaces = unresolvedPairFaces.filter(f=> f!==primaryFace); const releaseOrder=[]; state.dice.forEach((f,i)=>{ if (secondaryPairFaces.includes(f)) releaseOrder.push({index:i,type:'secondaryPair'}); }); const spriority={ heart:1, energy:2, attack:3 }; state.dice.forEach((f,i)=>{ if(!['one','two','three'].includes(f) && keep.has(i)) releaseOrder.push({index:i,type:'special',pr:spriority[f]||5}); }); releaseOrder.sort((a,b)=>{ if (a.type!==b.type) return a.type==='secondaryPair'?-1:1; return (a.pr||0)-(b.pr||0); }); const targetFree = rollsRemaining===1 ? 2:1; for(const cand of releaseOrder){ if (freeDice>=targetFree) break; if (keep.delete(cand.index)){ releasedIndices.push(cand.index); freeDice++; } } }
    if (rollsRemaining===1){ const pairMeta=state.numbers.filter(n=> n.pair && !n.formed).map(n=>({face:n.face,count:n.count})); if (pairMeta.length>1){ pairMeta.forEach(pm=>{ if (pm.face===primaryFace) return; const idxs=[]; state.dice.forEach((f,i)=>{ if(f===pm.face) idxs.push(i); }); const keptIdxs=idxs.filter(i=> keep.has(i)); if (keptIdxs.length===2){ const releaseIndex=keptIdxs[keptIdxs.length-1]; keep.delete(releaseIndex); releasedIndices.push(releaseIndex); } }); } }
    let keptFinal=Array.from(keep).sort((a,b)=>a-b); if (branchSim && branchSim.best){ const currentSpecialUtility = keptFinal.reduce((acc,idx)=>{ const face=state.dice[idx]; if (face==='attack') return acc + 8 + (state.criticalThreat?4:0); if (face==='energy') return acc + (state.phase==='early'?7: state.phase==='mid'?5:3); if (face==='heart' && !state.player.isInTokyo && state.player.health < state.player.maxHealth) return acc + (state.player.health<=CFG.healingCriticalHP?9:4); return acc; },0); const currentScore = (ev.total * (CFG.formedSetBase*0.05)) + currentSpecialUtility; if (branchSim.best.score > currentScore * 1.08){ keptFinal = branchSim.best.kept; releasedIndices.push('branch-adjust'); } }
    freeDice = state.dice.length - keptFinal.length; let heuristicNote=''; if (releasedIndices.length){ heuristicNote = ` | heuristic: freed ${releasedIndices.length} die${releasedIndices.length>1?'s':''}`; }
    const improvingFaces=[]; const trialCount=freeDice * state.rollsRemaining; if (freeDice>0 && state.rollsRemaining>0){ state.numbers.forEach(n=>{ if (n.count<3){ const needed=1; let p=0; for(let x=needed;x<=trialCount;x++){ p += choose(trialCount,x)*Math.pow(1/6,x)*Math.pow(5/6,trialCount-x); } improvingFaces.push({face:n.face,p}); } }); if (goal && !improvingFaces.find(f=>f.face===goal.face)){ let pGoal=0; for(let x=1;x<=trialCount;x++){ pGoal += choose(trialCount,x)*Math.pow(1/6,x)*Math.pow(5/6,trialCount-x); } improvingFaces.push({face:goal.face,p:pGoal}); } }
    let improvementChance=0; if (improvingFaces.length){ let logNo=0; improvingFaces.forEach(f=>{ const pn=Math.max(0, Math.min(1, 1 - f.p)); logNo += Math.log(pn); }); improvementChance = 1 - Math.exp(logNo); }
    let action='reroll'; const unresolvedPairs=state.numbers.filter(n=> n.pair && !n.formed).length; const personality=state.personality || { risk:3, aggression:3, strategy:3 }; const riskFactor=(personality.risk - 3); const adaptiveMinKept=Math.max(3, CFG.earlyStopMinKept + (riskFactor<=0 ? -riskFactor : 0)); const adaptiveEVThreshold = CFG.earlyStopImprovementThreshold + (riskFactor * -0.07); if (rollsRemaining>0){ if (kept.length>=adaptiveMinKept && ev.total < adaptiveEVThreshold && unresolvedPairs===0) action='endRoll'; } else action='endRoll'; if (rollsRemaining>=2 && action==='endRoll') action='reroll'; const explanationFragments=[]; if (goal) explanationFragments.push(`pursuing ${goal.face} set`); if (unresolvedPairs>0) explanationFragments.push(`${unresolvedPairs} live pair${unresolvedPairs>1?'s':''}`); if (state.cardSummary.attackBoost) explanationFragments.push('attack boost'); if (state.cardSummary.energyEngine) explanationFragments.push('energy engine'); if (state.cardSummary.healEngine) explanationFragments.push('healing synergy'); if (state.cardSummary.extraDie) explanationFragments.push('extra-die odds'); const evClause = action==='endRoll'? `marginal gain ${ev.total.toFixed(2)} < threshold ${adaptiveEVThreshold.toFixed(2)}`: `projected gain ${ev.total.toFixed(2)} â‰¥ threshold ${adaptiveEVThreshold.toFixed(2)}`; let reasonSentence = explanationFragments.length? `${evClause} while ${explanationFragments.join(', ')}`: evClause; if (rollsRemaining>=2 && action==='reroll') reasonSentence+=' (exploration)'; const reasonParts=[reasonSentence]; const confidence = action==='endRoll'? (rollsRemaining>0?0.8:0.92):0.6; let yieldSuggestion=false; if (player.isInTokyo){ const threateningEnemies = state.player.gameState?.players?.filter(p=> !p.isEliminated && p.id!==player.id && p.health>0).length || 0; const lowHP = player.health <= CFG.healingCriticalHP; if (lowHP && threateningEnemies>=2){ yieldSuggestion=true; reasonParts.push('consider yielding Tokyo'); } }
    const evBreakdown = ev.items.map(it=>({ face:it.face, type:it.type, ev:+it.ev.toFixed(3) })); const branchAnalysis = branchSim? { best: branchSim.best? { tag: branchSim.best.tag, score: branchSim.best.score, kept: branchSim.best.kept, improvementEV: branchSim.best.improvementEV, specialUtility: branchSim.best.specialUtility }:null, considered: branchSim.evaluated.slice(0,8) }: null; if (branchAnalysis?.best && !reasonParts.join(' ').includes('branch')){ reasonParts.push(`branch ${branchAnalysis.best.tag} score ${branchAnalysis.best.score}`); } const projection=this._projectTwoRollEV(state, new Set(keptFinal), deterministicCtx); const t1=performance.now(); AIDecisionProfiler.record('assembleDecision', t1-t0);
    const decisionObj = { action, keepDice: keptFinal, reason: reasonParts.join(' ') + heuristicNote, confidence, yieldSuggestion, techMeta:{ keptCount: kept.length, evGain: ev.total, unresolvedPairs, adaptiveEVThreshold, adaptiveMinKept, extraDie: state.cardSummary.extraDie||0 }, goal, releasedIndices, improvementChance:+improvementChance.toFixed(3), improvingFaces:Array.from(improvingFaces), evBreakdown, improvementEV:ev.total, branchAnalysis, projection };
    if (deterministicCtx?.active){
      decisionObj.deterministic = { seed: deterministicCtx.seed, trials: projection?.trials || deterministicCtx.trialsOverride, turnCycleId: deterministicCtx.turnCycleId, decisionIndex: deterministicCtx.decisionIndex };
    }
    return decisionObj; }
  _enforceInvariants(decision, state, rollsRemaining){ const counts=state.counts; ['one','two','three'].forEach(face=>{ if (counts[face]===2){ const idxs=[]; state.dice.forEach((f,i)=>{ if(f===face) idxs.push(i); }); const kept=idxs.filter(i=> decision.keepDice.includes(i)); if (kept.length===1){ idxs.forEach(i=> decision.keepDice.push(i)); decision.reason+=' | inv:pair restore'; if (typeof window!=='undefined') window.NewAIOverrideStats.pairProtect++; } } }); if (decision.action==='endRoll' && rollsRemaining>0){ const pairFaces=['one','two','three'].filter(f=> counts[f]===2); if (pairFaces.length>=2){ decision.action='reroll'; decision.reason+=' | inv:multi-pair continue'; } } if (decision.action==='reroll' && rollsRemaining>0){ const pairFaces=['one','two','three'].filter(f=> counts[f]===2); const keptSet=new Set(decision.keepDice); const freeDiceNow = state.dice.length - keptSet.size; if (freeDiceNow===0 && pairFaces.length>0){ let primaryFace=null; ['three','two','one'].forEach(f=>{ if (counts[f]===2 && primaryFace===null) primaryFace=f; }); const releaseCandidates=[]; ['one','two','three'].forEach(f=>{ if (f!==primaryFace && counts[f]===2){ state.dice.forEach((face,i)=>{ if(face===f) releaseCandidates.push({i,pr:1}); }); } }); const spriority={ heart:2, energy:3, attack:4 }; state.dice.forEach((face,i)=>{ if(!['one','two','three'].includes(face)) releaseCandidates.push({i,pr:spriority[face]||5}); }); releaseCandidates.sort((a,b)=> a.pr - b.pr); if (releaseCandidates.length){ const rel=releaseCandidates[0]; keptSet.delete(rel.i); decision.keepDice=Array.from(keptSet).sort((a,b)=>a-b); decision.reason+=' | inv:forced free die'; } } } if (decision.action==='endRoll' && rollsRemaining>0 && counts.attack>=4){ const singleNumber=['one','two','three'].some(f=> counts[f]===1); if (singleNumber){ decision.action='reroll'; decision.reason+=' | inv:attack cluster'; } } decision.keepDice=Array.from(new Set(decision.keepDice)).sort((a,b)=>a-b); return decision; }
  _canon(f){ switch(f){ case '1': return 'one'; case '2': return 'two'; case '3': return 'three'; default: return f; } }
  _getOrInitPlayerMemory(player){ if (!player._aiMemory) player._aiMemory={ purchases:[], counts:{} }; return player._aiMemory; }
  _extractCardFeatures(card){ const features=new Set(); if(!card) return features; const name=(card.name||'').toLowerCase(); if (name.includes('extra') && name.includes('head')) features.add('extraDie'); if (name.includes('brain')) features.add('extraReroll'); if (name.includes('attack') || name.includes('spiked') || name.includes('fire')) features.add('attack'); if (name.includes('heal') || name.includes('regeneration') || name.includes('rapid')) features.add('heal'); if (name.includes('energy') || name.includes('metabolism') || name.includes('store')) features.add('energy'); if (name.includes('victory') || name.includes('point') || name.includes('news')) features.add('vp'); if (Array.isArray(card.effects)){ card.effects.forEach(e=>{ const type=(e.type||'').toLowerCase(); if (type==='extradie') features.add('extraDie'); else if (type==='extrareroll') features.add('extraReroll'); else if (type==='attackbonus') features.add('attack'); else if (type==='bonusenergy') features.add('energy'); else if (type==='healpoints') features.add('heal'); else if (type==='victorypoints') features.add('vp'); }); } return features; }
  _getSynergyMatrix(){ return { extraDie:{ extraReroll:1.15, attack:1.08, vp:1.05 }, extraReroll:{ extraDie:1.15, attack:1.07, vp:1.04 }, attack:{ extraDie:1.08, extraReroll:1.07, energy:1.03 }, energy:{ extraDie:1.05, vp:1.05 }, heal:{ energy:1.04, vp:1.03 }, vp:{ extraDie:1.05, extraReroll:1.04 } }; }
  _computeSynergyMultiplier(existingFeatures, newFeatures){ const matrix=this._getSynergyMatrix(); let mult=1.0; newFeatures.forEach(nf=>{ existingFeatures.forEach(ef=>{ const row=matrix[ef]; if (row && row[nf]) mult*=row[nf]; const row2=matrix[nf]; if (row2 && row2[ef]) mult*=row2[ef]; }); }); return mult; }
  recordPowerCardPurchase(player, card){ const mem=this._getOrInitPlayerMemory(player); mem.purchases.push({ id:card.id||card.name, ts:Date.now(), name:card.name }); const feats=this._extractCardFeatures(card); feats.forEach(f=> mem.counts[f]=(mem.counts[f]||0)+1); }
  _getDiminishingFactor(feature, count){ if (count<=0) return 1.0; if (count===1) return 0.82; if (count===2) return 0.6; if (count===3) return 0.45; return 0.35; }
  optimizePowerCardPortfolio(availableCards, player){ if(!Array.isArray(availableCards)||!availableCards.length) return { cards:[], totalCost:0, strategy:'none', efficiency:0, rationale:{ perCard:[], aggregate:{} } }; const energyBudget=player.energy||0; if (energyBudget<=0) return { cards:[], totalCost:0, strategy:'none', efficiency:0, rationale:{ perCard:[], aggregate:{} } }; const baseWeights={ extraDie:22, extraReroll:18, attack:14, energy:12, heal:10, vp:8 }; const { aggression=0.5, strategy:stratBias=0.5, risk=0.5 }=player.personality||{}; const mem=this._getOrInitPlayerMemory(player); const ownedCounts={ ...mem.counts }; const ownedFeaturesSet=new Set(Object.keys(ownedCounts).filter(k=>ownedCounts[k]>0)); const computeBase=(features)=>{ let v=0; features.forEach(f=> v+=(baseWeights[f]||5)); return v; }; const cardMeta=availableCards.map(c=>{ const feats=this._extractCardFeatures(c); return { card:c, features:feats, cost:c.cost||0 }; }); const rationalePerCard=[]; const chosenCards=[]; let spent=0; let cumulativeScore=0; const simulatedCounts={ ...ownedCounts }; const simulatedFeatures=new Set(ownedFeaturesSet); while(true){ let best=null; for(const meta of cardMeta){ if (chosenCards.includes(meta.card)) continue; if (meta.cost + spent > energyBudget) continue; const base=computeBase(meta.features); let drFactors=[]; meta.features.forEach(f=>{ const cnt=simulatedCounts[f]||0; drFactors.push(this._getDiminishingFactor(f,cnt)); }); const diminishing=drFactors.length? (drFactors.reduce((a,b)=>a+b,0)/drFactors.length):1; const synergyMult=this._computeSynergyMultiplier(simulatedFeatures, meta.features)||1; let personalityMult=1; if (meta.features.has('attack')) personalityMult *= (1 + (aggression-0.5)*0.6); if (meta.features.has('extraDie') || meta.features.has('extraReroll')) personalityMult *= (1 + (stratBias-0.5)*0.5); if (meta.features.has('vp')) personalityMult *= (1 + (stratBias-0.5)*0.3); if (meta.features.has('heal') && player.health <=4) personalityMult *= 1.25; if (meta.features.has('extraDie') && risk>0.6) personalityMult *= 1.1; const rawAdjusted = base * diminishing * synergyMult * personalityMult; const net = meta.cost>0? rawAdjusted / Math.pow(meta.cost,0.92): rawAdjusted; if (!best || net > best.net) best={ meta, base, diminishing, synergyMult, personalityMult, rawAdjusted, net }; } if (!best || best.net<=5) break; chosenCards.push(best.meta.card); spent+=best.meta.cost; cumulativeScore+=best.rawAdjusted; best.meta.features.forEach(f=>{ simulatedCounts[f]=(simulatedCounts[f]||0)+1; simulatedFeatures.add(f); }); rationalePerCard.push({ cardId:best.meta.card.id||best.meta.card.name, name:best.meta.card.name, features:[...best.meta.features], base:best.base, diminishing:best.diminishing, synergyMultiplier:best.synergyMult, personalityMultiplier:best.personalityMult, cost:best.meta.cost, netValue:best.net, rawAdjusted:best.rawAdjusted }); if (spent>=energyBudget) break; } const featureTally={}; for(const r of rationalePerCard){ r.features.forEach(f=> featureTally[f]=(featureTally[f]||0)+1); } let strategyLabel='balanced'; if (Object.keys(featureTally).length){ strategyLabel = Object.entries(featureTally).sort((a,b)=> b[1]-a[1])[0][0]; } const efficiency = spent>0? cumulativeScore / spent : 0; const rationaleAggregate={ energyBudget, energySpent:spent, unspent:energyBudget-spent, selectedCount:chosenCards.length, featureTally, strategicIntent:strategyLabel, stoppedReason:(spent>=energyBudget?'budget_exhausted':'marginal_value_below_threshold'), thresholdUsed:5 }; return { cards:chosenCards, totalCost:spent, strategy:strategyLabel, efficiency, rationale:{ perCard:rationalePerCard, aggregate:rationaleAggregate } }; }
  evaluateDefensiveCardPurchase(card, player){ if(!card) return { shouldBuyDefensively:false, defensiveValue:0, denialReason:'' }; const name=(card.name||'').toLowerCase(); let defensiveValue=0; let reasonParts=[]; if (name.includes('head')){ defensiveValue+=8; reasonParts.push('deny extra die'); } if (name.includes('brain')){ defensiveValue+=7; reasonParts.push('deny reroll'); } if (name.includes('heal') || name.includes('regeneration')){ defensiveValue+=6; reasonParts.push('deny sustain'); } if (name.includes('attack') || name.includes('spiked') || name.includes('fire')){ defensiveValue+=5; reasonParts.push('deny offense'); } const threats=(player.gameState?.players||[]).filter(p=> p.id!==player.id && !p.isEliminated); const highVP=threats.some(t=> t.victoryPoints>=15); if (highVP) defensiveValue*=1.2; const lowHPEnemy=threats.some(t=> t.health<=3); if (lowHPEnemy && (name.includes('heal')||name.includes('regeneration'))) defensiveValue*=0.6; const should=defensiveValue>=9 && (card.cost||0) <= player.energy; return { shouldBuyDefensively:should, defensiveValue, denialReason:reasonParts.join(', ') }; }
  explain(decision){ if (!decision) return 'No decision.'; const parts=[]; parts.push(`Action: ${decision.action}`); if (decision.goal) parts.push(`Goal: ${decision.goal.face}`); if (decision.improvementEV!=null) parts.push(`EV ${decision.improvementEV.toFixed(2)}`); if (decision.improvementChance!=null) parts.push(`Improve ${(decision.improvementChance*100).toFixed(1)}%`); if (decision.branchAnalysis?.best){ parts.push(`Branch ${decision.branchAnalysis.best.tag}`); } parts.push(`Conf ${(decision.confidence*100).toFixed(0)}%`); return parts.join(' | '); }
}

if (typeof window !== 'undefined') { window.NewAIDecisionEngine = AIDecisionEngine; if (!window.AIDecisionEngine) window.AIDecisionEngine = AIDecisionEngine; }
export { AIDecisionEngine, AIDecisionProfiler };
